a) The Browser app will perform checks on the certificate, unlike the initial ClickMe app. When checking the fake certificate sent from the Burp Suite, it does not pass all the checks that a real certificate signed by a CA would pass. In this case, the certificate's common name does not match the name the client is expecting.
b) The unmodified app does not do any checks to see if the certificate received from the other endpoint is acceptable, inside trustAllHosts(). Thus, the fake certificate sent from the Burp Suite went through easily so the HTTPS connections were stablished. This behavior is "fail-open", as even though a faulty certificate is sent, the app continues to operate.
c) I acquired the required credentials (the good certificate) from good.pem in the ad-servers folder. I hardcoded the certificate as a string in the server code and created a TrustManager that trusts this certificate. This replaced the trustAllHosts() code from before, in the new method- trustGoodHosts().
d) For a Browser app, it would be infeasible to store on the client acceptable certificates when there are so many possible web servers that the client would want to talk to. In such a situation, I would use a Certificate Authority to sign an arbitrary server's public key certificate, and have the client authenticate it by verifying the CA's signature on the certificate.
